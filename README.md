# آزمایش نهم آزمایشگاه مهندسی نرم‌افزار
- نونا قاضی‌زاده ۹۸۱۷۱۰۰۷
- رضا عبداله‌زاده ۹۷۱۰۶۱۳۲
## توضیحات آزمایش
<p align="justify">
در این آزمایش ما یک معماری مایکروسرویس را شامل سه سرویس کاربر، محصول و سفارش توسعه دادیم به طوری که در کنار هم ساختار یک فروشگاه اینترنتی را نمایش میدهند.
</p>

## جزئیات پیاده‌سازی
### سرویس کاربر
<p align="justify">
در سرویس کاربر، کلاینت میتواند با apiهای موجود
کاربر جدید بسازد، به آن کاربر لاگین کند و پروفایل خود را دیده یا آپدیت کند.
تمام مراحل احراز هویت به کمک jwt token انجام شده و از متد 
دکوریتور token_required برای بررسی و بازگرداندن کاربر مربوط به هر توکن استفاده می‌شود.
کاربرها در یک دیکشنری نگه‌داری میشوند.

یک api با نام validate_login نیز وجود دارد که سرویس‌های دیگر میتوانند با صدا زدن آن از احراز هویت کلاینت‌ها مطمئن شوند.
</p>

### سرویس محصول
<p align="justify">
در این بخش محصولات که در یک دیکشنری پایتون نگه‌داری میشوند میتوان
تمام محصولات یا یک محصول خاصی را گرفت، به محصولی خاص یک نظر اضافه کرد و همینطور apiای به نام validate_product 
قرار  گرفته است که با آن سرویس‌های دیگر بتوانند از صحت وجود یک محصول اطمینان حاصل کنند.
</p>

### سرویس سفارش
<p align="justify">
در این سرویس با در اختیار داشتن توکن هر کاربر میتواند، سفارش‌های خود را ببیند، جزئیات یک سفارش خاص را ببیند و سفارش جدید ثبت کند یا سفارشات قبلی خود را کنسل کند.
این کار با ارسال درخواست به سرویس کاربر و سرویس محصول برای اطمینان از اهراز هویت و صحت محصول بکار میرود.
</p>

### توسعه‌ی DockerFileها
برای هر یک از سرویس‌های داکر فایل جداگانه توسعه یافته است به طوری که 


## مراحل انجام آزمایش

### سرویس کاربر
<p align="justify">
در این سرویس 
  
</p>

### الگوی prototype

<p align="justify">
  همانطور که گفته شده است ابتدا تست‌ها برای کلاس‌های prototype پیاده‌سازی می‌کنیم. سناریو پیاده‌سازی شده در مورد شبیه‌سازی یک دایره ایجاد شده با latitude،  longitude و شعاع است با پیاده‌سازی تست‌ها و اجرای آن برنامه ما به خطای کامپایلی خورد زیرا هنوز کدی پیاده‌سازی نشده است. مانند تصویر زیر:
  
  ![](https://github.com/re0078/SWE_Lab_HW6/assets/59199865/6e64bb04-b496-42a3-b976-995d04d9aad4)

  سپس کلاس‌ مورد نیاز به org.example.prototypepattern اضافه می ‌شود در نتیجه تست‌ها بدون هیچ اروری اجرا می‌شوند. مانند تصویر زیر:
  
![](https://github.com/re0078/SWE_Lab_HW6/assets/59199865/5d02ae1a-e7b1-4d3f-8381-b11f48325fd4)  
</p>

### الگوی builder

<p align="justify">
همانطور که گفته شده است ابتدا تست‌ها برای کلاس‌های builder پیاده‌سازی می‌کنیم. سناریو پیاده‌سازی شده در مورد ایجاد یک سفارش خرید با قابلیت customize کردن است با پیاده‌سازی تست‌ها و اجرای آن برنامه ما به خطای کامپایلی خورد زیرا هنوز کدی پیاده‌سازی نشده است. مانند تصویر زیر:
  
![](https://github.com/re0078/SWE_Lab_HW6/assets/59199865/3bb4047a-0715-4ea0-8da6-8e62b31b8469)
  
سپس کلاس‌ مورد نیاز به org.example.builderpattern اضافه می ‌شود در نتیجه تست‌ها بدون هیچ اروری اجرا می‌شوند. مانند تصویر زیر:
  
![](https://github.com/re0078/SWE_Lab_HW6/assets/59199865/af24cb3c-d3c8-49a4-b3c7-40c61fc9243c)  
  
</p>

### پیاده‌سازی نهایی
<p align="justify">
  بعد از پیاده‌سازی نهایی به منظور اطمینان تمام تست‌ها را اجرا می‌کنیم و همانطور که در تصویر زیر مشخص است، تمام تست‌ها بدون ارور اجرا می‌شود:
  
  ![](https://github.com/re0078/SWE_Lab_HW6/assets/59199865/4971e986-54db-463e-967f-4b7871af2a4d)
  </p>

## پرسش‌ها
### سوال ۱

<p dir="rtl" align="justify">
<i>
creational patterns
</i>
این الگو مکانیزم‌هایی برای تولید object تعریف می‌کند که انعطاف‌پذیری و استفاده دوباره از کد بالا رود.
</p>
  
<p dir="rtl" align="justify">
<i>
structural patterns
</i>.
  این الگو به ما می‌گوید چگونه داخل یک structure بزرگ classها و objectهایمان را پیاده کنیم به طوری که اون structure انعطاف پذیر و کارا بماند.
</p>

<p dir="rtl" align="justify">
<i>
behavioral patterns
</i>
این الگو با الگوریتم‌ها و تخصیص مسئولیت‌ها بین اشیا سروکار دارند.
</p>


### سوال ۲

سه الگو بیان شده در این آزمایش مربوط به دسته creational pattern است.


### سوال ۳
<p align="justify">
به طور کلی اصول SOLID مجموعه‌ای از اصول است که به ما نمی‌گوید دقیقا چگونه کدمان را پیاده کنیم بلکه می‌گوید کد باید این ویژگی‌‌ها را داشته باشد. اما Design Patternها به ما به طور خاص به ما می‌گویند که چگونه کدمان را طراحی کنیم تا به هدفی خاص برسیم.
به بیانی دیگر اصول SOLID مجموعه ای از اصول هستند که به طراحی بهتر سیستم‌های شی گرا کمک می‌کنند. از سوی دیگر، الگوهای طراحی GoF راه‌حل‌های طراحی اثبات شده برای مشکلات تکراری هستند. در حالی که اصول SOLID به هیچ حوزه مشکل خاصی مرتبط نیستند و در هر سناریویی صادق هستند، الگوهای طراحی GoF راه‌حل‌های خاصی برای مشکلات خاص هستند.
</p>

### سوال ۴
<p align="justify">
  الگوی طراحی Singleton یک الگوی creational است که برای اطمینان از اینکه تنها یک نمونه از یک کلاس در یک زبان شی‌گرا وجود دارد استفاده می‌شود. بحث‌هایی در مورد اینکه آیا الگوی Singleton هر یک از اصول SOLID را نقض می کند وجود دارد.
</p>
<p align="justify">
  برخی استدلال می‌کنند که الگوی Singleton می‌تواند اصل open/close یا همان OCP را نقض کند، زیرا معمولا به‌گونه‌ای پیاده‌سازی می‌شود که از وراثت جلوگیری می‌کند. با این حال، دیگران استدلال می‌کنند که ذاتاً OCP را نقض نمی‌کند و اتفاقاً اغلب در نقض OCP توسط توسعه‌دهندگانی که کتاب GoF را نخوانده‌اند اجرا می‌شود.
</p>
<p align="justify">
همچنین بحث‌هایی در مورد اینکه آیا الگوی Singleton اصل signle responsibility یا همان SRP را نقض می‌کند، وجود دارد. برخی استدلال می‌کنند که این کار را انجام می دهد زیرا creation و life cycle خود را کنترل می‌کند و به دلیل این که یک نمونه‌ی مشترک را در توسط classها و objectهای مختلف share می‌کند که کار‌های گوناگونی انجام دهند. با این حال، دیگران استدلال می‌کنند که SRP را نقض نمی‌کند، زیرا محدود کردن تنها یک شی ربطی به عملکرد کلاس ندارد.
</p>





